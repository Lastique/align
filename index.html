<!DOCTYPE html>
<!--
 Copyright (c) 2014 Glen Joseph Fernandes
 glenfe at live dot com

 Distributed under the Boost Software License,
 Version 1.0. (See accompanying file LICENSE_1_0.txt
 or copy at http://boost.org/LICENSE_1_0.txt)
-->
<html>
<head>
<title>Boost.Align</title>
<meta charset="utf-8">
<style>
  body {
    background: #fff;
    color: #000;
  }
  a {
    color: #00f;
    text-decoration: none;
  }
  pre {
    white-space: pre-wrap;
  }
  #contents {
    list-style-type: lower-roman;
  }
  .note {
    white-space: nowrap;
  }
</style>
</head>
<body>
  <h1>boost.align</h1>
  <p>&copy; 2014 Glen Fernandes</p>
  <h3>Contents</h3>
  <ol id="contents">
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#rationale">Rationale</a></li>
    <li><a href="#vocabulary">Vocabulary</a></li>
    <li><a href="#synopsis">Synopsis</a></li>
    <li><a href="#align">align</a></li>
    <li><a href="#aligned_alloc">aligned_alloc</a></li>
    <li><a href="#aligned_free">aligned_free</a></li>
    <li><a href="#aligned_allocator">aligned_allocator</a></li>
    <li><a href="#aligned_allocator_adaptor">aligned_allocator_adaptor</a></li>
    <li><a href="#aligned_delete">aligned_delete</a></li>
    <li><a href="#is_aligned">is_aligned</a></li>
    <li><a href="#examples">Examples</a></li>
    <li><a href="#testing">Testing</a></li>
    <li><a href="#acknowledgments">Acknowledgments</a></li>
    <li><a href="#history">History</a></li>
    <li><a href="#license">License</a></li>
  </ol>
  <h2 id="introduction">Introduction</h2>
  <p>The header <a href="#synopsis">&lt;boost/align.hpp&gt;</a>
    provides function <code>align</code> for implementations which do
    not have the C++11 standard library <code>std::align</code>
    function available.</p>
  <p>It provides allocation and deallocation functions,
    <code>aligned_alloc</code> and <code>aligned_free</code>, as
    their functionality is not yet available in the C++ standard
    library. They use platform specific functions, if available,
    or use standard library functions in conjunction with
    <code>align</code>.</p>
  <p>It provides C++ allocators, class templates
    <code>aligned_allocator</code> and
    <code>aligned_allocator_adaptor</code>, which respect alignment.
    The first uses <code>aligned_alloc</code> and
    <code>aligned_free</code> while the second uses the allocator in
    conjunction with <code>align</code>.</p>
  <p>It provides a deleter, class <code>aligned_delete</code>, which
    makes use of <code>aligned_free</code>.</p>
  <p>It also provides function <code>is_aligned</code> to test the
    alignment of a pointer.</p>
  <h2 id="rationale">Rationale</h2>
  <p>C++11 added the ability to specify increased alignment
    (over-alignment) for class types. Unfortunately,
    <code>::operator new</code> allocation functions, <code>new</code>
    expressions, and the default allocator,
    <code>std::allocator</code>, do not support dynamic memory
    allocation of over-aligned data.</p>
  <p>The <code>aligned_alloc</code> function can be used in place of
    <code>::operator new</code> to specify the alignment of the memory
    allocated.</p>
  <p>The <code>aligned_allocator</code> class template can be used in
    place of <code>std::allocator</code> as an alignment-aware default
    allocator.</p>
  <p>The <code>aligned_allocator_adaptor</code> class template can be
    used to adapt any allocator into an alignment-aware allocator.</p>
  <p>The <code>aligned_delete</code> class can be used in place of the
    default deleter, <code>std::default_delete</code>, for any objects
    allocated with <code>aligned_alloc</code>.</p>
  <h2 id="vocabulary">Vocabulary</h2>
  <h3>N3485 3.11 [basic.align]</h3>
  <blockquote>
    <sup>1</sup> Object types have <b>alignment requirements</b>
    which place restrictions on the addresses at which an object of
    that type may be allocated. An <b>alignment</b> is an
    implementation-defined integer value representing the number of
    bytes between successive addresses at which a given object can be
    allocated. An object type imposes an alignment requirement on
    every object of that type; stricter alignment can be requested
    using the alignment specifier.
  </blockquote>
  <blockquote>
    <sup>2</sup> A <b>fundamental alignment</b> is represented by an
    alignment less than or equal to the greatest alignment supported
    by the implementation in all contexts, which is equal to
    <code>alignof(std::max_align_t)</code>. The alignment required
    for a type might be different when it is used as the type of a
    complete object and when it is used as the type of a
    subobject. <span class="note">[ <em>Example:</em></span>
    <blockquote>
      <pre><code>struct B { long double d; };
struct D : virtual B { char c; };</code></pre>
    </blockquote>
    When <code>D</code> is the type of a complete object, it will
    have a subobject of type <code>B</code>, so it must be aligned
    appropriately for a <code>long double</code>. If <code>D</code>
    appears as a subobject of another object that also has
    <code>B</code> as a virtual base class, the <code>B</code>
    subobject might be part of a different subobject, reducing the
    alignment requirements on the <code>D</code> subobject.
    <span class="note">&mdash; <em>end example</em> ]</span> The
    result of the <code>alignof</code> operator reflects the alignment
    requirement of the type in the complete-object case.
  </blockquote>
  <blockquote>
    <sup>3</sup> An <b>extended alignment</b> is represented by an
    alignment greater than <code>alignof(std::max_align_t)</code>. It
    is implementation-defined whether any extended alignments are
    supported and the contexts in which they are supported. A type
    having an extended alignment requirement is an
    <b>over-aligned type</b>. <span class="note">[
    <em>Note:</em></span> every over-aligned type is or contains a
    class type to which extended alignment applies (possibly through a
    non-static data member). <span class="note">&mdash; <em>end
    note</em> ]</span>
  </blockquote>
  <blockquote>
    <sup>4</sup> Alignments are represented as values of the type
    <code>std::size_t</code>. Valid alignments include only those
    values returned by an <code>alignof</code> expression for the
    fundamental types plus an additional implementation-defined set
    of values, which may be empty. Every alignment value shall be a
    non-negative integral power of two.
  </blockquote>
  <h2 id="synopsis">Synopsis</h2>
  <pre><code>namespace boost {
    void* <a href="#align">align</a>(std::size_t alignment, std::size_t size,
        void*&amp; ptr, std::size_t&amp; space);

    void* <a href="#aligned_alloc">aligned_alloc</a>(std::size_t alignment,
        std::size_t size) noexcept;

    void <a href="#aligned_free">aligned_free</a>(void* ptr) noexcept;

    template&lt;class T, std::size_t Alignment = 1&gt;
    class <a href="#aligned_allocator">aligned_allocator</a>;

    template&lt;std::size_t Alignment&gt;
    class <a href="#aligned_allocator">aligned_allocator</a>&lt;void, Alignment&gt;;

    template&lt;class T1, class T2, std::size_t Alignment&gt;
    bool operator==(const aligned_allocator&lt;T1,
        Alignment&gt;&amp;, const aligned_allocator&lt;T2,
        Alignment&gt;&amp;) noexcept;

    template&lt;class T1, class T2, std::size_t Alignment&gt;
    bool operator!=(const aligned_allocator&lt;T1,
        Alignment&gt;&amp;, const aligned_allocator&lt;T2,
        Alignment&gt;&amp;) noexcept;

    template&lt;class Allocator, std::size_t Alignment = 1&gt;
    class <a href="#aligned_allocator_adaptor">aligned_allocator_adaptor</a>;

    template&lt;class A1, class A2, std::size_t Alignment&gt;
    bool operator==(const aligned_allocator_adaptor&lt;A1,
        Alignment&gt;&amp; a, const aligned_allocator_adaptor&lt;A2,
        Alignment&gt;&amp; b) noexcept;

    template&lt;class A1, class A2, std::size_t Alignment&gt;
    bool operator!=(const aligned_allocator_adaptor&lt;A1,
        Alignment&gt;&amp; a, const aligned_allocator_adaptor&lt;A2,
        Alignment&gt;&amp; b) noexcept;

    class <a href="#aligned_delete">aligned_delete</a>;

    bool <a href="#is_aligned">is_aligned</a>(std::size_t alignment,
        const void* ptr) noexcept;
}</code></pre>
  <h2 id="align">align</h2>
  <pre><code>void* align(std::size_t alignment, std::size_t size,
    void*&amp; ptr, std::size_t&amp; space);</code></pre>
  <blockquote>
    <b>Effects:</b> If it is possible to fit
    <code>size</code> bytes of storage aligned by alignment into the
    buffer pointed to by <code>ptr</code> with length
    <code>space</code>, the function updates <code>ptr</code> to
    point to the first possible address of such storage and decreases
    <code>space</code> by the number of bytes used for alignment.
    Otherwise, the function does nothing.
  </blockquote>
  <blockquote>
    <b>Requires:</b>
    <blockquote>
      <p>&mdash; <code>alignment</code> shall be a fundamental
        alignment value or an extended alignment value, and shall be a
        power of two</p>
      <p>&mdash; <code>ptr</code> shall point to contiguous storage of
        at least <code>space</code> bytes</p>
    </blockquote>
  </blockquote>
  <blockquote>
    <b>Returns:</b> A null pointer if the requested aligned buffer
    would not fit into the available space, otherwise the adjusted
    value of <code>ptr</code>.
  </blockquote>
  <blockquote>
    <b>Note:</b> The function updates its <code>ptr</code> and
    <code>space</code> arguments so that it can be called repeatedly
    with possibly different <code>alignment</code> and
    <code>size</code> arguments for the same buffer.
  </blockquote>
  <h2 id="aligned_alloc">aligned_alloc</h2>
  <pre><code>void* aligned_alloc(std::size_t alignment,
    std::size_t size) noexcept;</code></pre>
  <blockquote>
    <b>Description:</b> The <code>aligned_alloc</code>
    function allocates space for an object whose alignment is
    specified by <code>alignment</code>, whose size is specified by
    <code>size</code>, and whose value is indeterminate. The value of
    <code>alignment</code> shall be a power of two.
  </blockquote>
  <blockquote>
    <b>Returns:</b> The <code>aligned_alloc</code> function returns
    either a null pointer or a pointer to the allocated space.
  </blockquote>
  <blockquote>
    <b>Note:</b> On certain platforms, the alignment may be rounded
    up to <code>alignof(void*)</code> and the space allocated may be
    slightly larger than <code>size</code> bytes, by an additional
    <code>sizeof(void*)</code> and <code>alignment - 1</code> bytes.
  </blockquote>
  <h2 id="aligned_free">aligned_free</h2>
  <pre><code>void aligned_free(void* ptr) noexcept;</code></pre>
  <blockquote>
    <b>Description:</b> The <code>aligned_free</code>
    function causes the space pointed to by <code>ptr</code> to be
    deallocated, that is, made available for further allocation. If
    <code>ptr</code> is a null pointer, no action occurs. Otherwise,
    if the argument does not match a pointer earlier returned by the
    <code>aligned_alloc</code> function, or if the space has been
    deallocated by a call to <code>aligned_free</code>, the behavior
    is undefined.
  </blockquote>
  <blockquote>
    <b>Returns:</b> The <code>aligned_free</code> function returns
    no value.
  </blockquote>
  <h2 id="aligned_allocator">aligned_allocator</h2>
  <pre><code>template&lt;class T, std::size_t Alignment = 1&gt;
class aligned_allocator;

template&lt;std::size_t Alignment&gt;
class aligned_allocator&lt;void, Alignment&gt; {
public:
    typedef void value_type;
    typedef void* pointer;
    typedef const void* const_pointer;

    template&lt;class U&gt;
    struct rebind {
        typedef aligned_allocator&lt;U, Alignment&gt; other;
    };
};

template&lt;class T, std::size_t Alignment&gt;
class aligned_allocator {
public:
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef void* void_pointer;
    typedef const void* const_void_pointer;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
    typedef T&amp; reference;
    typedef const T&amp; const_reference;

    template&lt;class U&gt;
    struct rebind {
        typedef aligned_allocator&lt;U, Alignment&gt; other;
    };

    aligned_allocator() noexcept = default;

    template&lt;class U&gt;
    aligned_allocator(const aligned_allocator&lt;U,
        Alignment&gt;&amp;) noexcept;

    pointer address(reference x) const noexcept;

    const_pointer address(const_reference x) const noexcept;

    pointer allocate(size_type n,
        const_void_pointer = nullptr);

    void deallocate(pointer p, size_type);

    constexpr size_type max_size() const noexcept;

    template&lt;class U, class... Args&gt;
    void construct(U* memory, Args&amp;&amp;... args);

    template&lt;class U, class V&gt;
    void construct(U* memory, V&amp;&amp; value);

    template&lt;class U, class V&gt;
    void construct(U* memory, const V&amp; value);

    template&lt;class U&gt;
    void construct(U* memory);

    template&lt;class U&gt;
    void destroy(U* memory);
};

template&lt;class T1, class T2, std::size_t Alignment&gt;
bool operator==(const aligned_allocator&lt;T1,
    Alignment&gt;&amp;, const aligned_allocator&lt;T2,
    Alignment&gt;&amp;) noexcept;

template&lt;class T1, class T2, std::size_t Alignment&gt;
bool operator!=(const aligned_allocator&lt;T1,
    Alignment&gt;&amp;, const aligned_allocator&lt;T2,
    Alignment&gt;&amp;) noexcept;</code></pre>
  <h3>aligned_allocator requirements</h3>
  <p>The <code>Alignment</code> template parameter is the minimum
    alignment to specify for allocations, if it is larger than the
    alignment of the value type. The value of <code>Alignment</code>
    shall be a power of two.</p>
  <h3>aligned_allocator members</h3>
  <p>Except for the destructor, member functions of the aligned
    allocator shall not introduce data races as a result of concurrent
    calls to those member functions from different threads. Calls to
    these functions that allocate or deallocate a particular unit of
    storage shall occur in a single total order, and each such
    deallocation call shall happen before the next allocation (if any)
    in this order.</p>
  <pre><code>pointer address(reference x) const noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b> The actual address of the object
    referenced by <code>x</code>, even in the presence of an
    overloaded operator&amp;.
  </blockquote>
  <pre><code>const_pointer address(const_reference x) const noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b> The actual address of the object
    referenced by <code>x</code>, even in the presence of an
    overloaded operator&amp;.
  </blockquote>
  <pre><code>pointer allocate(size_type n,
    const_void_pointer = nullptr);</code></pre>
  <blockquote>
    <b>Returns:</b> A pointer to the initial element of an array of
    storage of size <code>n * sizeof(T)</code>, aligned on the
    maximum of the minimum alignment specified and the alignment of
    objects of type <code>T</code>.
  </blockquote>
  <blockquote>
    <b>Remarks:</b> The storage is obtained by calling
    <code>aligned_alloc(std::size_t, std::size_t)</code>.
  </blockquote>
  <blockquote>
    <b>Throws:</b> <code>std::bad_alloc</code> if the storage cannot
    be obtained.
  </blockquote>
  <pre><code>void deallocate(pointer p, size_type);</code></pre>
  <blockquote>
    <b>Requires:</b> <code>p</code> shall be a pointer value
    obtained from <code>allocate()</code>.
  </blockquote>
  <blockquote>
    <b>Effects:</b> Deallocates the storage referenced by
    <code>p</code>.
  </blockquote>
  <blockquote>
    <b>Remarks:</b> Uses <code>aligned_free(void*)</code>.
  </blockquote>
  <pre><code>constexpr size_type max_size() const noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b> The largest value <em>N</em> for which the call
    <code>allocate(N)</code> might succeed.
  </blockquote>
  <pre><code>template&lt;class U, class... Args&gt;
void construct(U* p, Args&amp;&amp;... args);</code></pre>
  <blockquote>
    <b>Effects:</b> <code>::new((void*)p)
    U(std::forward&lt;Args&gt;(args)...)</code>
  </blockquote>
  <pre><code>template&lt;class U&gt;
void destroy(U* p);</code></pre>
  <blockquote>
    <b>Effects:</b> <code>p-&gt;~U()</code>
  </blockquote>
  <h3>aligned_allocator globals</h3>
  <pre><code>template&lt;class T1, class T2, std::size_t Alignment&gt;
bool operator==(const aligned_allocator&lt;T1,
    Alignment&gt;&amp;, const aligned_allocator&lt;T2,
    Alignment&gt;&amp;) noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b> <code>true</code>.
  </blockquote>
  <pre><code>template&lt;class T1, class T2, std::size_t Alignment&gt;
bool operator!=(const aligned_allocator&lt;T1,
    Alignment&gt;&amp;, const aligned_allocator&lt;T2,
    Alignment&gt;&amp;) noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b> <code>false</code>.
  </blockquote>
  <h3>aligned_allocator notes</h3>
  <p>Specifying minimum alignment is generally only suitable for
    containers such as vector and undesirable with other, node-based,
    containers. For node-based containers, such as list, the node
    object would have the minimum alignment specified instead of the
    value type object.</p>
  <h2 id="aligned_allocator_adaptor">aligned_allocator_adaptor</h2>
  <pre><code>template&lt;class Allocator, std::size_t Alignment = 1&gt;
class aligned_allocator_adaptor
    : public Allocator {
private:
    typedef std::allocator_traits&lt;Allocator&gt; Traits;

public:
    typedef typename Traits::value_type value_type;
    typedef typename Traits::size_type size_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef void* void_pointer;
    typedef const void* const_void_pointer;
    typedef std::ptrdiff_t difference_type;

    template&lt;class U&gt;
    struct rebind {
        typedef aligned_allocator_adaptor&lt;typename Traits::
            template rebind_alloc&lt;U&gt;, Alignment&gt; other;
    };

    aligned_allocator_adaptor() = default;

    template&lt;class A&gt;
    explicit aligned_allocator_adaptor(A&amp;&amp; alloc) noexcept;

    template&lt;class A&gt;
    explicit aligned_allocator_adaptor(const A&amp; alloc) noexcept;

    template&lt;class U&gt;
    aligned_allocator_adaptor(const aligned_allocator_adaptor&lt;U,
        Alignment&gt;&amp; other) noexcept;

    Allocator&amp; base() noexcept;

    const Allocator&amp; base() const noexcept;

    pointer allocate(size_type n);

    pointer allocate(size_type n, const_void_pointer hint);

    void deallocate(pointer p, size_type n);
};

template&lt;class A1, class A2, std::size_t Alignment&gt;
bool operator==(const aligned_allocator_adaptor&lt;A1,
    Alignment&gt;&amp; a, const aligned_allocator_adaptor&lt;A2,
    Alignment&gt;&amp; b) noexcept;

template&lt;class A1, class A2, std::size_t Alignment&gt;
bool operator!=(const aligned_allocator_adaptor&lt;A1,
    Alignment&gt;&amp; a, const aligned_allocator_adaptor&lt;A2,
    Alignment&gt;&amp; b) noexcept;</code></pre>
  <h3>aligned_allocator_adaptor requirements</h3>
  <p>The <code>Alignment</code> template parameter is the minimum
    alignment to specify for allocations, if it is larger than the
    alignment of the value type. The value of <code>Alignment</code>
    shall be a fundamental alignment value or an extended alignment
    value, and shall be a power of two.</p>
  <h3>aligned_allocator_adaptor constructors</h3>
  <pre><code>aligned_allocator_adaptor() = default;</code></pre>
  <blockquote>
    <b>Effects:</b> value-initializes the
    <code>Allocator</code> base class.
  </blockquote>
  <pre><code>template&lt;class A&gt;
explicit aligned_allocator_adaptor(A&amp;&amp; alloc) noexcept;</code></pre>
  <blockquote>
    <b>Requires:</b> <code>Allocator</code> shall be
    constructible from <code>A</code>.
  </blockquote>
  <blockquote>
    <b>Effects:</b> initializes the <code>Allocator</code>
    base class with <code>std::forward&lt;A&gt;(alloc)</code>.
  </blockquote>
  <pre><code>template&lt;class U&gt;
aligned_allocator_adaptor(const aligned_allocator_adaptor&lt;U,
    Alignment&gt;&amp; other) noexcept;</code></pre>
  <blockquote>
    <b>Effects:</b> initializes the <code>Allocator</code>
    base class with the allocator from <code>other</code>.
  </blockquote>
  <h3>aligned_allocator_adaptor members</h3>
  <pre><code>Allocator&amp; base() noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b>
    <code>static_cast&lt;Allocator&amp;&gt;(*this)</code>.
  </blockquote>
  <pre><code>const Allocator&amp; base() const noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b>
    <code>static_cast&lt;const Allocator&amp;&gt;(*this)</code>.
  </blockquote>
  <pre><code>pointer allocate(size_type n);</code></pre>
  <blockquote>
    <b>Returns:</b> A pointer to the initial element of an array of
    storage of size <code>n * sizeof(value_type)</code>, aligned on
    the maximum of the minimum alignment specified and the alignment
    of objects of type <code>value_type</code>.
  </blockquote>
  <blockquote>
    <b>Remarks:</b> The storage is obtained by calling
    <code>A2::allocate</code> on an object <code>a2</code>, where
    <code>a2</code> of type <code>A2</code> is a rebound copy of
    <code>base()</code> where its <code>value_type</code> is
    unspecified.
  </blockquote>
  <blockquote>
    <b>Throws:</b> An exception thrown from
      <code>A2::allocate</code> if the storage cannot be obtained.
  </blockquote>
  <pre><code>pointer allocate(size_type n,
    const_void_pointer hint);</code></pre>
  <blockquote>
    <b>Requires:</b> <code>hint</code> is a value obtained by
    calling <code>allocate()</code> on any equivalent aligned
    allocator adaptor object, or else <code>nullptr</code>.
  </blockquote>
  <blockquote>
    <b>Returns:</b> A pointer to the initial element of an array of
    storage of size <code>n * sizeof(value_type)</code>, aligned on
    the maximum of the minimum alignment specified and the alignment
    of objects of type <code>value_type</code>.
  </blockquote>
  <blockquote>
    <b>Remarks:</b> The storage is obtained by calling
    <code>A2::allocate</code> on an object <code>a2</code>, where
    <code>a2</code> of type <code>A2</code> is a rebound copy of
    <code>base()</code> where its <code>value_type</code> is
    unspecified.
  </blockquote>
  <blockquote>
    <b>Throws:</b> An exception thrown from
      <code>A2::allocate</code> if the storage cannot be obtained.
  </blockquote>
  <pre><code>void deallocate(pointer p, size_type n);</code></pre>
  <blockquote>
    <b>Requires:</b> <code>p</code> shall be a pointer value
    obtained from <code>allocate()</code>. <code>n</code> shall equal
    the value passed as the first argument to the invocation of
    allocate which returned <code>p</code>.
  </blockquote>
  <blockquote>
    <b>Effects:</b> Deallocates the storage referenced by
    <code>p</code>.
  </blockquote>
  <blockquote>
    <b>Remarks:</b> Uses <code>A2::deallocate</code> on an object
    <code>a2</code>, where <code>a2</code> of type <code>A2</code>
    is a rebound copy of <code>base()</code> where its
    <code>value_type</code> is unspecified.
  </blockquote>
  <h3>aligned_allocator_adaptor operators</h3>
  <pre><code>template&lt;class A1, class A2, std::size_t Alignment&gt;
bool operator==(const aligned_allocator_adaptor&lt;A1,
    Alignment&gt;&amp; a, const aligned_allocator_adaptor&lt;A2,
    Alignment&gt;&amp; b) noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b> <code>a.base() == b.base()</code>.
  </blockquote>
  <pre><code>template&lt;class A1, class A2, std::size_t Alignment&gt;
bool operator!=(const aligned_allocator_adaptor&lt;A1,
    Alignment&gt;&amp; a, const aligned_allocator_adaptor&lt;A2,
    Alignment&gt;&amp; b) noexcept;</code></pre>
  <blockquote>
    <b>Returns:</b> <code>!(a == b)</code>.
  </blockquote>
  <h3>aligned_allocator_adaptor notes</h3>
  <p>This adaptor can be used with a C++11 allocator whose
    <code>pointer</code> type is a smart pointer but the adaptor will
    expose only raw pointers.</p>
  <h2 id="aligned_delete">aligned_delete</h2>
  <pre><code>class aligned_delete {
public:
    template&lt;class T&gt;
    void operator()(T* ptr) const
        noexcept(noexcept(ptr->~T()));
};</code></pre>
  <h3>aligned_delete members</h3>
  <pre><code>template&lt;class T&gt;
void operator()(T* ptr) const
    noexcept(noexcept(ptr->~T()));</code></pre>
  <blockquote>
    <b>Effects:</b> Calls <code>~T()</code> on <code>ptr</code>
    to destroy the object and then calls <code>aligned_free</code>
    on <code>ptr</code> to free the allocated memory.
  </blockquote>
  <blockquote>
    <b>Remarks:</b> If <code>T</code> is an incomplete type, the
    program is ill-formed.
  </blockquote>
  <h2 id="is_aligned">is_aligned</h2>
  <pre><code>bool is_aligned(std::size_t alignment,
    const void* ptr) noexcept;</code></pre>
  <blockquote>
    <b>Description:</b> The <code>is_aligned</code> function
    determines whether the space pointed to by <code>ptr</code> has
    alignment specified by <code>alignment</code>.
  </blockquote>
  <blockquote>
    <b>Returns:</b> The <code>is_aligned</code> function returns
    <code>true</code> if and only if <code>ptr</code> points to space
    that has alignment specified by <code>alignment</code>.
  </blockquote>
  <h2 id="examples">Examples</h2>
  <h3>aligned_ptr and make_aligned</h3>
  <pre><code>#include &lt;boost/align.hpp&gt;
#include &lt;memory&gt;

template&lt;class T&gt;
using aligned_ptr = std::unique_ptr&lt;T,
    boost::aligned_delete&gt;;

template&lt;class T, class... Args&gt;
inline aligned_ptr&lt;T&gt;
    make_aligned(Args&amp;&amp;... args)
{
    auto p = boost::aligned_alloc(alignof(T),
        sizeof(T));
    if (!p) {
        throw std::bad_alloc();
    }
    try {
        auto q = ::new(p)
            T(std::forward&lt;Args&gt;(args)...);
        return aligned_ptr&lt;T&gt;(q);
    } catch (...) {
        boost::aligned_free(p);
        throw;
    }
}

struct alignas(16) type {
    float data[4];
};

int main()
{
    auto p = make_aligned&lt;type&gt;();
    p->data[0] = 1.0f;
}</code></pre>
  <h3>aligned_vector</h3>
  <pre><code>#include &lt;boost/align.hpp&gt;
#include &lt;vector&gt;

template&lt;class T, std::size_t Alignment = 1&gt;
using aligned_vector = std::vector&lt;T,
    boost::aligned_allocator&lt;T, Alignment&gt; &gt;;

enum {
    cache_line = 64
};

int main()
{
    aligned_vector&lt;int, cache_line&gt; v(32);
    v[0] = 1;
}</code></pre>
  <h2 id="testing">Testing</h2>
  <p>The following compilers and platforms have been tested.</p>
  <ul>
    <li>clang 3.0, 3.1, 3.2, 3.4, 3.5, linux</li>
    <li>gcc 4.6, 4.7, 4.8, linux</li>
    <li>msvc 10.0, 11.0, 12.0, windows</li>
  </ul>
  <h2 id="acknowledgments">Acknowledgments</h2>
  <p>Thank you to everyone who helped review this library.</p>
  <ul>
    <li>Peter Dimov</li>
    <li>Andrey Semashev</li>
    <li>Bjorn Reese</li>
    <li>Steven Watanabe</li>
    <li>Anthony Polukhin</li>
    <li>Lars Viklund</li>
    <li>Michael Spencer</li>
  </ul>
  <p>Thank you to Ahmed Charles for managing the review.</p>
  <h2 id="history">History</h2>
  <p><b>2014.02.19.</b> Glen Fernandes first implemented
    Boost.Align.</p>
  <h2 id="license">License</h2>
  <p>Distributed under the
    <a href="http://boost.org/LICENSE_1_0.txt">Boost Software
    License, Version 1.0</a>.</p>
</body>
</html>
